<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>H·ªá Th·ªëng H·ªçc T·∫≠p Giao D·ªãch Th√¥ng Minh - XAU/USD</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e6e6e6;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(25, 25, 35, 0.95);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            padding: 30px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }
        
        h1 {
            color: #d4af37;
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5rem;
            text-shadow: 0 2px 10px rgba(212, 175, 55, 0.3);
            padding-bottom: 20px;
            border-bottom: 3px solid #d4af37;
            background: linear-gradient(45deg, #d4af37, #f7ef8a);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .panel {
            background: rgba(30, 30, 40, 0.9);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(100, 100, 120, 0.2);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .panel:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        }
        
        .panel-title {
            font-size: 1.4rem;
            font-weight: bold;
            margin-bottom: 20px;
            color: #d4af37;
            border-bottom: 2px solid rgba(212, 175, 55, 0.3);
            padding-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .panel-title::before {
            content: '';
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #d4af37;
            border-radius: 50%;
        }
        
        .control-group {
            margin-bottom: 18px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }
        
        label {
            display: inline-block;
            width: 220px;
            margin-bottom: 8px;
            font-weight: 500;
            color: #b0b0b0;
            font-size: 0.95rem;
        }
        
        input, select {
            padding: 12px 15px;
            border: 1px solid rgba(100, 100, 120, 0.4);
            border-radius: 8px;
            width: 220px;
            background: rgba(20, 20, 30, 0.8);
            color: #fff;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #d4af37;
            box-shadow: 0 0 0 2px rgba(212, 175, 55, 0.2);
        }
        
        button {
            background: linear-gradient(45deg, #d4af37, #b8941f);
            color: #1a1a2e;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.3s ease;
            font-size: 0.95rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(212, 175, 55, 0.4);
            background: linear-gradient(45deg, #e5c046, #c9a428);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.danger {
            background: linear-gradient(45deg, #ff4757, #ff3838);
            color: white;
        }
        
        button.danger:hover {
            background: linear-gradient(45deg, #ff6b81, #ff5252);
        }
        
        button.success {
            background: linear-gradient(45deg, #00b894, #00a085);
            color: white;
        }
        
        button.success:hover {
            background: linear-gradient(45deg, #26de81, #20bf6b);
        }
        
        button.info {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }
        
        button.info:hover {
            background: linear-gradient(45deg, #5dade2, #3498db);
        }
        
        button.warning {
            background: linear-gradient(45deg, #f39c12, #e67e22);
            color: white;
        }
        
        button.warning:hover {
            background: linear-gradient(45deg, #f1c40f, #f39c12);
        }
        
        .price-display {
            font-size: 2.2rem;
            font-weight: bold;
            text-align: center;
            margin: 25px 0;
            color: #d4af37;
            padding: 20px;
            background: rgba(30, 30, 40, 0.7);
            border-radius: 15px;
            border: 2px solid rgba(212, 175, 55, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .chart-container {
            height: 450px;
            margin-bottom: 30px;
            background: rgba(20, 20, 30, 0.8);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100, 100, 120, 0.2);
        }
        
        .trade-info {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .trade-box {
            flex: 1;
            min-width: 300px;
            background: rgba(25, 25, 35, 0.9);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-left: 5px solid #d4af37;
            transition: transform 0.3s ease;
        }
        
        .trade-box:hover {
            transform: translateY(-3px);
        }
        
        .trade-box.buy {
            border-left-color: #00b894;
            background: rgba(0, 184, 148, 0.05);
        }
        
        .trade-box.sell {
            border-left-color: #ff4757;
            background: rgba(255, 71, 87, 0.05);
        }
        
        .trade-box.closed {
            opacity: 0.7;
            background: rgba(40, 40, 50, 0.8);
        }
        
        .profit {
            color: #00b894;
            font-weight: bold;
        }
        
        .loss {
            color: #ff4757;
            font-weight: bold;
        }
        
        #historyList {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid rgba(100, 100, 120, 0.3);
            border-radius: 10px;
            padding: 15px;
            background: rgba(20, 20, 30, 0.8);
        }
        
        .history-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(100, 100, 120, 0.2);
            background: rgba(30, 30, 40, 0.5);
            margin-bottom: 8px;
            border-radius: 8px;
            transition: background 0.3s ease;
        }
        
        .history-item:hover {
            background: rgba(40, 40, 50, 0.7);
        }
        
        .history-item:last-child {
            border-bottom: none;
        }
        
        .status-bar {
            background: linear-gradient(45deg, #2c3e50, #34495e);
            color: white;
            padding: 18px 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }
        
        .status-item {
            margin: 0 5px;
            font-size: 0.95rem;
        }
        
        .status-value {
            font-weight: bold;
            padding: 4px 10px;
            border-radius: 6px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .sound-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .sound-control {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(20, 20, 30, 0.6);
            border-radius: 8px;
        }
        
        .notification {
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            background: rgba(52, 152, 219, 0.1);
            border-left: 4px solid #3498db;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .notification.success {
            background: rgba(46, 204, 113, 0.1);
            border-left-color: #2ecc71;
        }
        
        .notification.warning {
            background: rgba(241, 196, 15, 0.1);
            border-left-color: #f1c40f;
        }
        
        .notification.error {
            background: rgba(231, 76, 60, 0.1);
            border-left-color: #e74c3c;
        }
        
        .learning-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: rgba(30, 30, 40, 0.8);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(212, 175, 55, 0.2);
        }
        
        .stat-card h4 {
            color: #d4af37;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #fff;
            margin: 10px 0;
        }
        
        .pattern-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            margin: 3px;
            background: rgba(52, 152, 219, 0.2);
            color: #3498db;
            border: 1px solid rgba(52, 152, 219, 0.3);
        }
        
        .pattern-badge.success {
            background: rgba(46, 204, 113, 0.2);
            color: #2ecc71;
            border-color: rgba(46, 204, 113, 0.3);
        }
        
        .pattern-badge.danger {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
            border-color: rgba(231, 76, 60, 0.3);
        }
        
        .pattern-badge.warning {
            background: rgba(241, 196, 15, 0.2);
            color: #f1c40f;
            border-color: rgba(241, 196, 15, 0.3);
        }
        
        #suggestionsContainer {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(30, 30, 40, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(212, 175, 55, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(212, 175, 55, 0.7);
        }
        
        /* Responsive Design */
        @media (max-width: 1200px) {
            .container {
                padding: 20px;
            }
            
            .trade-box {
                min-width: 250px;
            }
        }
        
        @media (max-width: 768px) {
            .control-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            input, select {
                width: 100%;
            }
            
            .trade-box {
                min-width: 100%;
            }
            
            .status-bar {
                flex-direction: column;
                gap: 10px;
            }
            
            #suggestionsContainer {
                width: 90%;
                left: 5%;
                right: 5%;
            }
        }
        
        /* Animation for price change */
        @keyframes pricePulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .price-up {
            animation: pricePulse 0.5s ease;
            color: #2ecc71 !important;
        }
        
        .price-down {
            animation: pricePulse 0.5s ease;
            color: #e74c3c !important;
        }
        
        /* Loading animation */
        .loader {
            border: 3px solid rgba(212, 175, 55, 0.3);
            border-top: 3px solid #d4af37;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: rgba(30, 30, 40, 0.95);
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9rem;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        
        /* Trading button pulse animation */
        @keyframes tradePulse {
            0% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(212, 175, 55, 0); }
            100% { box-shadow: 0 0 0 0 rgba(212, 175, 55, 0); }
        }
        
        .trading-active {
            animation: tradePulse 2s infinite;
        }
        
        /* Badge for active trades */
        .badge {
            display: inline-block;
            padding: 3px 8px;
            font-size: 0.75rem;
            font-weight: bold;
            border-radius: 12px;
            margin-left: 8px;
        }
        
        .badge.success {
            background: #2ecc71;
            color: white;
        }
        
        .badge.danger {
            background: #e74c3c;
            color: white;
        }
        
        .badge.info {
            background: #3498db;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ H·ªÜ TH·ªêNG H·ªåC T·∫¨P GIAO D·ªäCH TH√îNG MINH - V√ÄNG (XAU/USD)</h1>
        
        <!-- STATUS BAR -->
        <div class="status-bar" id="tradingStatus">
            <div class="status-item">üîß Ch·∫ø ƒë·ªô: <span id="modeText" class="status-value">Th·ªß C√¥ng</span></div>
            <div class="status-item">üí∞ S·ªë d∆∞: <span id="balanceText" class="status-value profit">$1,000.00</span></div>
            <div class="status-item">üìä Gi√° hi·ªán t·∫°i: <span id="currentPrice" class="status-value">0.00</span> USD</div>
            <div class="status-item">üìà L·ªánh h√¥m nay: <span id="tradesCount" class="status-value">0</span></div>
            <div class="status-item">üîÑ L·ªánh ƒëang m·ªü: <span id="openTradesCount" class="status-value">0</span></div>
            <div class="status-item">üß† M·∫´u ƒë√£ h·ªçc: <span id="patternsCount" class="status-value">0</span></div>
        </div>
        
        <!-- PRICE DISPLAY -->
        <div class="price-display">
            <div>üí∞ GI√Å V√ÄNG HI·ªÜN T·∫†I</div>
            <div id="priceValue" style="font-size: 2.8rem; margin: 10px 0;">0.00 USD</div>
            <div id="priceChange" style="font-size: 1.2rem; opacity: 0.8;">ƒêang c·∫≠p nh·∫≠t...</div>
        </div>

        <!-- PH·∫¶N 1: GIAO D·ªäCH TH·ª¶ C√îNG -->
        <div class="panel">
            <div class="panel-title">‚ö° GIAO D·ªäCH TH·ª¶ C√îNG</div>
            
            <div class="control-group">
                <label for="virtualBalance">üí∞ S·ªë d∆∞ ·∫£o (USD):</label>
                <input type="number" id="virtualBalance" value="1000" min="100" step="100">
            </div>
            
            <div class="control-group">
                <label for="lotSize">üì¶ Kh·ªëi l∆∞·ª£ng (lot):</label>
                <input type="number" id="lotSize" value="0.1" min="0.01" step="0.01">
            </div>
            
            <div class="control-group">
                <label for="leverage">‚öñÔ∏è ƒê√≤n b·∫©y:</label>
                <select id="leverage">
                    <option value="1">1x</option>
                    <option value="5">5x</option>
                    <option value="10" selected>10x</option>
                    <option value="20">20x</option>
                    <option value="50">50x</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="stopLoss">üõ°Ô∏è Stop Loss (pips):</label>
                <input type="number" id="stopLoss" value="50" min="10" step="10">
            </div>
            
            <div class="control-group">
                <label for="takeProfit">üéØ Take Profit (pips):</label>
                <input type="number" id="takeProfit" value="65" min="10" step="10">
            </div>
            
            <div style="margin-top: 25px; text-align: center;">
                <button onclick="executeManualTrade('BUY')" class="success trading-active">
                    üìà MUA (BUY)
                </button>
                <button onclick="executeManualTrade('SELL')" class="danger trading-active">
                    üìâ B√ÅN (SELL)
                </button>
                <button onclick="closeAllTrades()" class="warning">
                    ‚úñÔ∏è ƒê√ìNG T·∫§T C·∫¢
                </button>
                <button onclick="showAdvancedSettings()" class="info">
                    ‚öôÔ∏è C√ÄI ƒê·∫∂T N√ÇNG CAO
                </button>
            </div>
            
            <div id="currentTradeDetails" style="margin-top: 25px; display: none;">
                <div class="panel-title" style="margin-top: 0;">üìä L·ªÜNH ƒêANG M·ªû</div>
                <div class="trade-info" id="tradeBoxes"></div>
            </div>
        </div>

        <!-- PH·∫¶N 2: H·ªÜ TH·ªêNG H·ªåC T·∫¨P TH√îNG MINH -->
        <div class="panel">
            <div class="panel-title">üß† H·ªÜ TH·ªêNG H·ªåC T·∫¨P TH√îNG MINH</div>
            
            <!-- CH·∫æ ƒê·ªò HO·∫†T ƒê·ªòNG -->
            <div class="control-group">
                <label for="tradingMode">üéõÔ∏è Ch·∫ø ƒë·ªô ho·∫°t ƒë·ªông:</label>
                <select id="tradingMode" onchange="changeTradingMode()">
                    <option value="manual">üë®‚Äçüíº Th·ªß C√¥ng (T√¥i t·ª± trade)</option>
                    <option value="learning">üìö H·ªçc T·∫≠p (H·ªçc c√°ch t√¥i trade)</option>
                    <option value="suggestion">üí° ƒê·ªÅ Xu·∫•t (G·ª£i √Ω setup t∆∞∆°ng t·ª±)</option>
                    <option value="auto">ü§ñ T·ª± ƒê·ªông (T·ª± trade sau khi h·ªçc)</option>
                </select>
            </div>
            
            <!-- C√ÄI ƒê·∫∂T H·ªåC T·∫¨P -->
            <div class="control-group">
                <label>üéØ ƒê·ªô tin c·∫≠y t·ªëi thi·ªÉu:</label>
                <div style="display: flex; align-items: center; gap: 15px; flex: 1;">
                    <input type="range" id="minConfidence" min="50" max="95" value="70" style="flex: 1;">
                    <span id="confidenceValue" style="font-weight: bold; min-width: 50px;">70%</span>
                </div>
            </div>
            
            <div class="control-group">
                <label>üìä S·ªë m·∫´u t·ªëi thi·ªÉu:</label>
                <input type="number" id="minSamples" value="5" min="3" max="20" style="width: 100px;">
                <span style="opacity: 0.8;">(c·∫ßn √≠t nh·∫•t X m·∫´u gi·ªëng nhau)</span>
            </div>
            
            <!-- N√öT ƒêI·ªÄU KHI·ªÇN H·ªåC T·∫¨P -->
            <div style="margin-top: 25px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                <button onclick="startLearningMode()" class="info">
                    üìù B·∫ÆT ƒê·∫¶U H·ªåC
                </button>
                <button onclick="analyzeMyStrategy()" class="info">
                    üìä PH√ÇN T√çCH CHI·∫æN L∆Ø·ª¢C
                </button>
                <button onclick="exportLearningData()" class="success">
                    üíæ XU·∫§T D·ªÆ LI·ªÜU
                </button>
                <button onclick="clearLearningData()" class="danger">
                    üóëÔ∏è X√ìA D·ªÆ LI·ªÜU
                </button>
                <button onclick="resetAll()" class="warning">
                    üîÑ RESET T·∫§T C·∫¢
                </button>
            </div>
            
            <!-- TH·ªêNG K√ä H·ªåC T·∫¨P -->
            <div class="learning-stats" id="learningStats">
                <div class="stat-card">
                    <h4>üìà TH·ªêNG K√ä T·ªîNG QUAN</h4>
                    <div class="stat-value" id="totalPatterns">0</div>
                    <p>T·ªïng s·ªë m·∫´u ƒë√£ h·ªçc</p>
                    <div style="margin-top: 15px;">
                        <span class="pattern-badge success" id="winRate">0% Win Rate</span>
                        <span class="pattern-badge" id="avgConfidence">0% Tin c·∫≠y</span>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h4>üéØ M·∫™U TH√ÄNH C√îNG NH·∫§T</h4>
                    <div id="bestPattern" style="font-size: 1.1rem; margin: 10px 0;">Ch∆∞a c√≥ d·ªØ li·ªáu</div>
                    <p id="bestPatternStats">T·ªâ l·ªá th·∫Øng: 0%</p>
                </div>
                
                <div class="stat-card">
                    <h4>‚ö° TR·∫†NG TH√ÅI H·ªÜ TH·ªêNG</h4>
                    <div id="systemStatus" style="font-size: 1.1rem; margin: 10px 0; color: #2ecc71;">üü¢ ƒêang ho·∫°t ƒë·ªông</div>
                    <p id="lastAnalysis">L·∫ßn ph√¢n t√≠ch cu·ªëi: Ch∆∞a c√≥</p>
                    <div id="autoTradeStatus" style="margin-top: 10px; display: none;">
                        <span class="pattern-badge warning">ü§ñ AUTO-TRADE ƒêANG B·∫¨T</span>
                    </div>
                </div>
            </div>
            
            <!-- DANH S√ÅCH M·∫™U ƒê√É H·ªåC -->
            <div style="margin-top: 25px;">
                <div class="panel-title" style="margin-bottom: 15px;">üìã M·∫™U H√åNH ƒê√É H·ªåC</div>
                <div id="patternsList" style="max-height: 300px; overflow-y: auto; padding: 15px; background: rgba(20, 20, 30, 0.6); border-radius: 10px;">
                    <div style="text-align: center; padding: 20px; opacity: 0.7;">
                        Ch∆∞a c√≥ m·∫´u h√¨nh n√†o ƒë∆∞·ª£c h·ªçc. B·∫Øt ƒë·∫ßu trade th·ªß c√¥ng ƒë·ªÉ h·ªá th·ªëng h·ªçc h·ªèi!
                    </div>
                </div>
            </div>
        </div>

        <!-- PH·∫¶N 3: BI·ªÇU ƒê·ªí V√Ä PH√ÇN T√çCH -->
        <div class="panel">
            <div class="panel-title">üìä BI·ªÇU ƒê·ªí V√Ä PH√ÇN T√çCH</div>
            
            <div class="chart-container">
                <canvas id="mainChart"></canvas>
            </div>
            
            <div style="margin-top: 20px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                <button onclick="toggleChartType()" class="info">
                    üîÑ ƒê·ªîI LO·∫†I BI·ªÇU ƒê·ªí
                </button>
                <button onclick="updateChartData()" class="info">
                    üîÑ C·∫¨P NH·∫¨T D·ªÆ LI·ªÜU
                </button>
                <button onclick="clearChart()" class="danger">
                    üóëÔ∏è X√ìA BI·ªÇU ƒê·ªí
                </button>
                <button onclick="showChartSettings()" class="info">
                    ‚öôÔ∏è C√ÄI ƒê·∫∂T BI·ªÇU ƒê·ªí
                </button>
            </div>
            
            <!-- INDICATOR DISPLAY -->
            <div style="margin-top: 25px; display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                <div class="stat-card">
                    <h4>üìà RSI (14)</h4>
                    <div class="stat-value" id="rsiValue">0.00</div>
                    <div id="rsiStatus" style="font-size: 0.9rem;">ƒêang t√≠nh...</div>
                </div>
                
                <div class="stat-card">
                    <h4>üìä MACD</h4>
                    <div class="stat-value" id="macdValue">0.0000</div>
                    <div id="macdStatus" style="font-size: 0.9rem;">ƒêang t√≠nh...</div>
                </div>
                
                <div class="stat-card">
                    <h4>üìâ EMA (20)</h4>
                    <div class="stat-value" id="ema20Value">0.00</div>
                    <div id="ema20Status" style="font-size: 0.9rem;">ƒêang t√≠nh...</div>
                </div>
                
                <div class="stat-card">
                    <h4>üìà EMA (50)</h4>
                    <div class="stat-value" id="ema50Value">0.00</div>
                    <div id="ema50Status" style="font-size: 0.9rem;">ƒêang t√≠nh...</div>
                </div>
            </div>
        </div>

        <!-- PH·∫¶N 4: L·ªäCH S·ª¨ V√Ä C·∫¢NH B√ÅO -->
        <div class="panel">
            <div class="panel-title">üìù L·ªäCH S·ª¨ V√Ä C·∫¢NH B√ÅO</div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px;">
                <!-- L·ªäCH S·ª¨ GIAO D·ªäCH -->
                <div>
                    <h4 style="color: #d4af37; margin-bottom: 15px;">üìã L·ªäCH S·ª¨ GIAO D·ªäCH</h4>
                    <div id="historyList" style="max-height: 300px;"></div>
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <button onclick="clearTradeHistory()" class="danger small">üßπ X√≥a L·ªãch S·ª≠</button>
                        <button onclick="exportTradeHistory()" class="info small">üì§ Xu·∫•t CSV</button>
                    </div>
                </div>
                
                <!-- C·∫¢NH B√ÅO GI√Å -->
                <div>
                    <h4 style="color: #d4af37; margin-bottom: 15px;">üîî C·∫¢NH B√ÅO GI√Å</h4>
                    <div class="control-group" style="flex-direction: column; align-items: flex-start;">
                        <label for="alertPrices">M·ªëc gi√° c·∫£nh b√°o:</label>
                        <input type="text" id="alertPrices" placeholder="V√≠ d·ª•: 2180,2200,2150" style="width: 100%;">
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <button onclick="setupPriceAlerts()" class="success small">‚úÖ B·∫≠t C·∫£nh B√°o</button>
                        <button onclick="clearAlerts()" class="danger small">üóëÔ∏è X√≥a C·∫£nh B√°o</button>
                    </div>
                    <div id="alertsList" style="margin-top: 15px; max-height: 150px; overflow-y: auto;">
                        <!-- Alerts will appear here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- PH·∫¶N 5: C√ÄI ƒê·∫∂T √ÇM THANH -->
        <div class="panel">
            <div class="panel-title">üîä C√ÄI ƒê·∫∂T √ÇM THANH</div>
            
            <div class="sound-controls">
                <div class="sound-control">
                    <label>üîä M·ªü l·ªánh:</label>
                    <input type="file" id="openSoundInput" accept="audio/*" style="flex: 1;">
                </div>
                <div class="sound-control">
                    <label>üéØ Take Profit:</label>
                    <input type="file" id="tpSoundInput" accept="audio/*" style="flex: 1;">
                </div>
                <div class="sound-control">
                    <label>üõ°Ô∏è Stop Loss:</label>
                    <input type="file" id="slSoundInput" accept="audio/*" style="flex: 1;">
                </div>
                <div class="sound-control">
                    <label>üí° ƒê·ªÅ xu·∫•t:</label>
                    <input type="file" id="suggestionSoundInput" accept="audio/*" style="flex: 1;">
                </div>
                <div class="sound-control">
                    <label>‚ö†Ô∏è C·∫£nh b√°o:</label>
                    <input type="file" id="alertSoundInput" accept="audio/*" style="flex: 1;">
                </div>
            </div>
            
            <div class="control-group" style="margin-top: 20px;">
                <label for="useGlobalSound">üîà D√πng √¢m thanh chung:</label>
                <input type="checkbox" id="useGlobalSound" style="width: auto;">
                <label for="soundVolume">üîä √Çm l∆∞·ª£ng:</label>
                <input type="range" id="soundVolume" min="0" max="100" value="50" style="width: 100px;">
                <span id="volumeValue">50%</span>
            </div>
            
            <div style="margin-top: 25px; display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                <button onclick="saveSoundSettings()" class="success">üíæ L∆ØU C√ÄI ƒê·∫∂T</button>
                <button onclick="testAllSounds()" class="info">‚ñ∂Ô∏è KI·ªÇM TRA √ÇM THANH</button>
                <button onclick="resetSoundSettings()" class="danger">üîÑ RESET √ÇM THANH</button>
            </div>
        </div>

        <!-- TH√îNG TIN H·ªÜ TH·ªêNG -->
        <div style="margin-top: 30px; padding: 20px; background: rgba(30, 30, 40, 0.6); border-radius: 12px; text-align: center; font-size: 0.9rem; opacity: 0.8;">
            <p>üöÄ <strong>H·ªÜ TH·ªêNG H·ªåC T·∫¨P GIAO D·ªäCH TH√îNG MINH</strong> | Phi√™n b·∫£n 2.0 | ¬© 2024</p>
            <p>üí° H·ªá th·ªëng n√†y h·ªçc h·ªèi t·ª´ c√°ch b·∫°n trade v√† ƒë·ªÅ xu·∫•t/auto-trade khi c√≥ setup t∆∞∆°ng t·ª± v·ªõi ƒë·ªô tin c·∫≠y cao</p>
        </div>
    </div>

    <!-- CONTAINER CHO ƒê·ªÄ XU·∫§T -->
    <div id="suggestionsContainer"></div>

    <!-- MODAL CHO C√ÄI ƒê·∫∂T N√ÇNG CAO -->
    <div id="advancedSettingsModal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 2000; justify-content: center; align-items: center;">
        <div style="background: rgba(30, 30, 40, 0.95); padding: 30px; border-radius: 20px; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;">
            <h3 style="color: #d4af37; margin-bottom: 20px;">‚öôÔ∏è C√ÄI ƒê·∫∂T N√ÇNG CAO</h3>
            <!-- Advanced settings content will be added here -->
            <div style="margin-top: 30px; display: flex; gap: 15px; justify-content: flex-end;">
                <button onclick="closeAdvancedSettings()" class="danger">ƒê√ìNG</button>
                <button onclick="saveAdvancedSettings()" class="success">L∆ØU C√ÄI ƒê·∫∂T</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== KHAI B√ÅO BI·∫æN TO√ÄN C·ª§C ====================
        const FINNHUB_API_KEY = 'd1l6t99r01qt4thebangd1l6t99r01qt4thebao0';
        
        // Bi·∫øn c·ªët l√µi
        let currentPrice = 0;
        let previousPrice = 0;
        let virtualBalance = 1000;
        let tradesToday = 0;
        let currentTrades = [];
        let ws = null;
        let mainChart = null;
        
        // Bi·∫øn h·ªçc t·∫≠p
        let tradingMode = 'manual';
        let learnedPatterns = [];
        let priceHistory = [];
        let indicatorHistory = [];
        let alertLevels = [];
        let alertedLevels = new Set();
        
        // Bi·∫øn √¢m thanh
        let sounds = {
            open: new Audio('https://assets.mixkit.co/active_storage/sfx/286/286-preview.mp3'),
            tp: new Audio('https://assets.mixkit.co/active_storage/sfx/257/257-preview.mp3'),
            sl: new Audio('https://assets.mixkit.co/active_storage/sfx/255/255-preview.mp3'),
            suggestion: new Audio('https://assets.mixkit.co/active_storage/sfx/286/286-preview.mp3'),
            alert: new Audio('https://assets.mixkit.co/active_storage/sfx/250/250-preview.mp3')
        };
        
        let useGlobalSound = false;
        let soundVolume = 50;
        
        // C√°c m·∫´u h√¨nh
        const PATTERN_TYPES = {
            SUPPORT_BOUNCE: { name: 'H·ªó tr·ª£ ph·∫£n h·ªìi', color: '#2ecc71' },
            RESISTANCE_REJECTION: { name: 'Kh√°ng c·ª± t·ª´ ch·ªëi', color: '#e74c3c' },
            BREAKOUT: { name: 'Ph√° v·ª°', color: '#3498db' },
            TREND_CONTINUATION: { name: 'Ti·∫øp di·ªÖn xu h∆∞·ªõng', color: '#9b59b6' },
            TREND_REVERSAL: { name: 'ƒê·∫£o chi·ªÅu', color: '#f39c12' },
            OVERBOUGHT: { name: 'Qu√° mua', color: '#e74c3c' },
            OVERSOLD: { name: 'Qu√° b√°n', color: '#2ecc71' }
        };

        // ==================== KH·ªûI T·∫†O H·ªÜ TH·ªêNG ====================
        async function initializeSystem() {
            console.log('üöÄ ƒêang kh·ªüi t·∫°o h·ªá th·ªëng...');
            
            // Load d·ªØ li·ªáu ƒë√£ l∆∞u
            loadSavedData();
            
            // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì
            initChart();
            
            // K·∫øt n·ªëi WebSocket
            connectWebSocket();
            
            // Thi·∫øt l·∫≠p c√°c s·ª± ki·ªán
            setupEventListeners();
            
            // C·∫≠p nh·∫≠t giao di·ªán
            updateAllDisplays();
            
            // B·∫Øt ƒë·∫ßu c√°c interval
            startIntervals();
            
            console.log('‚úÖ H·ªá th·ªëng ƒë√£ kh·ªüi ƒë·ªông th√†nh c√¥ng!');
            showNotification('üöÄ H·ªá th·ªëng h·ªçc t·∫≠p th√¥ng minh ƒë√£ s·∫µn s√†ng!', 'success');
        }

        function loadSavedData() {
            // Load d·ªØ li·ªáu t·ª´ localStorage
            virtualBalance = parseFloat(localStorage.getItem('virtualBalance')) || 1000;
            tradingMode = localStorage.getItem('tradingMode') || 'manual';
            learnedPatterns = JSON.parse(localStorage.getItem('learnedPatterns')) || [];
            currentTrades = JSON.parse(localStorage.getItem('currentTrades')) || [];
            
            // Load c√†i ƒë·∫∑t √¢m thanh
            useGlobalSound = localStorage.getItem('useGlobalSound') === 'true';
            soundVolume = parseInt(localStorage.getItem('soundVolume')) || 50;
            
            // Update UI
            document.getElementById('virtualBalance').value = virtualBalance;
            document.getElementById('tradingMode').value = tradingMode;
            document.getElementById('useGlobalSound').checked = useGlobalSound;
            document.getElementById('soundVolume').value = soundVolume;
            document.getElementById('volumeValue').textContent = soundVolume + '%';
            
            // Update volume for all sounds
            Object.values(sounds).forEach(sound => {
                sound.volume = soundVolume / 100;
            });
        }

        function saveData() {
            localStorage.setItem('virtualBalance', virtualBalance.toString());
            localStorage.setItem('tradingMode', tradingMode);
            localStorage.setItem('learnedPatterns', JSON.stringify(learnedPatterns));
            localStorage.setItem('currentTrades', JSON.stringify(currentTrades));
            localStorage.setItem('useGlobalSound', useGlobalSound.toString());
            localStorage.setItem('soundVolume', soundVolume.toString());
        }

        // ==================== WEBSOCKET CONNECTION ====================
        function connectWebSocket() {
            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log('WebSocket ƒë√£ k·∫øt n·ªëi');
                    return;
                }
                
                ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);
                
                ws.onopen = () => {
                    console.log('‚úÖ ƒê√£ k·∫øt n·ªëi WebSocket');
                    showNotification('üîå ƒê√£ k·∫øt n·ªëi v·ªõi server gi√°', 'success');
                    ws.send(JSON.stringify({ type: 'subscribe', symbol: 'OANDA:XAU_USD' }));
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        
                        if (data.type === 'trade' && data.data && data.data.length > 0) {
                            const trade = data.data[0];
                            if (trade && trade.p) {
                                await processNewPrice(parseFloat(trade.p));
                            }
                        }
                    } catch (error) {
                        console.error('L·ªói x·ª≠ l√Ω WebSocket message:', error);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    showNotification('‚ö†Ô∏è L·ªói k·∫øt n·ªëi WebSocket', 'error');
                };
                
                ws.onclose = () => {
                    console.log('WebSocket ƒë√≥ng, ƒëang k·∫øt n·ªëi l·∫°i...');
                    setTimeout(connectWebSocket, 3000);
                };
                
            } catch (error) {
                console.error('L·ªói k·∫øt n·ªëi WebSocket:', error);
                setTimeout(connectWebSocket, 5000);
            }
        }

        async function processNewPrice(newPrice) {
            if (isNaN(newPrice) || newPrice <= 0) return;
            
            // C·∫≠p nh·∫≠t animation cho gi√°
            updatePriceDisplay(newPrice);
            
            // L∆∞u v√†o l·ªãch s·ª≠
            priceHistory.push({
                timestamp: new Date(),
                price: newPrice,
                volume: Math.random() * 100 // Mock volume
            });
            
            // Gi·ªõi h·∫°n l·ªãch s·ª≠
            if (priceHistory.length > 200) {
                priceHistory.shift();
            }
            
            // C·∫≠p nh·∫≠t indicators
            updateIndicators();
            
            // Ki·ªÉm tra trade ƒëang m·ªü
            checkOpenTrades();
            
            // Ki·ªÉm tra c·∫£nh b√°o gi√°
            checkPriceAlerts(newPrice);
            
            // Ki·ªÉm tra c∆° h·ªôi giao d·ªãch n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô suggestion/auto
            if (tradingMode === 'suggestion' || tradingMode === 'auto') {
                checkTradingOpportunities();
            }
            
            // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì
            updateChart();
            
            saveData();
        }

        function updatePriceDisplay(newPrice) {
            const priceElement = document.getElementById('priceValue');
            const previous = currentPrice;
            currentPrice = newPrice;
            
            // Animation
            if (previous > 0) {
                if (newPrice > previous) {
                    priceElement.classList.remove('price-down');
                    priceElement.classList.add('price-up');
                    setTimeout(() => priceElement.classList.remove('price-up'), 500);
                } else if (newPrice < previous) {
                    priceElement.classList.remove('price-up');
                    priceElement.classList.add('price-down');
                    setTimeout(() => priceElement.classList.remove('price-down'), 500);
                }
            }
            
            priceElement.textContent = newPrice.toFixed(2) + ' USD';
            previousPrice = previous;
            
            // Update change percentage
            if (previous > 0) {
                const change = ((newPrice - previous) / previous * 100).toFixed(2);
                const changeElement = document.getElementById('priceChange');
                changeElement.textContent = `${change > 0 ? '+' : ''}${change}%`;
                changeElement.style.color = change >= 0 ? '#2ecc71' : '#e74c3c';
            }
        }

        // ==================== INDICATOR CALCULATIONS ====================
        function updateIndicators() {
            if (priceHistory.length < 20) return;
            
            // T√≠nh RSI
            const rsi = calculateRSI(14);
            document.getElementById('rsiValue').textContent = rsi.toFixed(2);
            const rsiStatus = document.getElementById('rsiStatus');
            if (rsi < 30) {
                rsiStatus.textContent = 'Qu√° b√°n';
                rsiStatus.style.color = '#2ecc71';
            } else if (rsi > 70) {
                rsiStatus.textContent = 'Qu√° mua';
                rsiStatus.style.color = '#e74c3c';
            } else {
                rsiStatus.textContent = 'Trung l·∫≠p';
                rsiStatus.style.color = '#3498db';
            }
            
            // T√≠nh MACD
            const macd = calculateMACD();
            document.getElementById('macdValue').textContent = macd.histogram.toFixed(4);
            const macdStatus = document.getElementById('macdStatus');
            macdStatus.textContent = macd.histogram > 0 ? 'TƒÉng' : 'Gi·∫£m';
            macdStatus.style.color = macd.histogram > 0 ? '#2ecc71' : '#e74c3c';
            
            // T√≠nh EMA
            const ema20 = calculateEMA(20);
            const ema50 = calculateEMA(50);
            document.getElementById('ema20Value').textContent = ema20.toFixed(2);
            document.getElementById('ema50Value').textContent = ema50.toFixed(2);
            
            document.getElementById('ema20Status').textContent = 
                currentPrice > ema20 ? 'Tr√™n EMA20' : 'D∆∞·ªõi EMA20';
            document.getElementById('ema50Status').textContent = 
                currentPrice > ema50 ? 'Tr√™n EMA50' : 'D∆∞·ªõi EMA50';
        }

        function calculateRSI(period = 14) {
            if (priceHistory.length < period + 1) return 50;
            
            let gains = 0;
            let losses = 0;
            
            for (let i = priceHistory.length - period; i < priceHistory.length; i++) {
                const change = priceHistory[i].price - priceHistory[i - 1].price;
                if (change > 0) gains += change;
                else losses += Math.abs(change);
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            
            if (avgLoss === 0) return 100;
            
            const rs = avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }

        function calculateEMA(period) {
            if (priceHistory.length < period) return currentPrice;
            
            const prices = priceHistory.slice(-period).map(p => p.price);
            const multiplier = 2 / (period + 1);
            
            let ema = prices[0];
            for (let i = 1; i < prices.length; i++) {
                ema = (prices[i] - ema) * multiplier + ema;
            }
            
            return ema;
        }

        function calculateMACD() {
            const ema12 = calculateEMA(12);
            const ema26 = calculateEMA(26);
            const macdLine = ema12 - ema26;
            const signalLine = calculateEMAOfValue(macdLine, 9);
            const histogram = macdLine - signalLine;
            
            return {
                macdLine,
                signalLine,
                histogram,
                bullish: histogram > 0
            };
        }

        function calculateEMAOfValue(value, period) {
            // Simplified EMA calculation for a single value
            return value * (2 / (period + 1));
        }

        // ==================== TRADING FUNCTIONS ====================
        function executeManualTrade(action) {
            if (!currentPrice || currentPrice <= 0) {
                showNotification('‚ö†Ô∏è Ch∆∞a c√≥ gi√°, kh√¥ng th·ªÉ v√†o l·ªánh', 'error');
                return;
            }
            
            const lotSize = parseFloat(document.getElementById('lotSize').value);
            const leverage = parseInt(document.getElementById('leverage').value);
            const stopLossPips = parseInt(document.getElementById('stopLoss').value);
            const takeProfitPips = parseInt(document.getElementById('takeProfit').value);
            
            // T√≠nh to√°n entry, SL, TP
            const entryPrice = currentPrice;
            let stopLoss, takeProfit;
            
            if (action === 'BUY') {
                stopLoss = entryPrice - (stopLossPips / 10); // 1 pip = 0.1 USD cho v√†ng
                takeProfit = entryPrice + (takeProfitPips / 10);
            } else {
                stopLoss = entryPrice + (stopLossPips / 10);
                takeProfit = entryPrice - (takeProfitPips / 10);
            }
            
            // T·∫°o trade object
            const trade = {
                id: Date.now(),
                action: action,
                entryPrice: entryPrice,
                stopLoss: stopLoss,
                takeProfit: takeProfit,
                lotSize: lotSize,
                leverage: leverage,
                status: 'OPEN',
                openTime: new Date(),
                type: 'MANUAL',
                learnedPatternId: null
            };
            
            // Th√™m v√†o danh s√°ch
            currentTrades.push(trade);
            
            // Ghi nh·∫≠n v√†o h·ªá th·ªëng h·ªçc t·∫≠p n·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô learning
            if (tradingMode === 'learning') {
                recordTradePattern(trade, 'manual');
            }
            
            // C·∫≠p nh·∫≠t giao di·ªán
            updateTradeDisplay();
            updateStatusBar();
            
            // Ph√°t √¢m thanh
            playSound('open');
            
            // Log
            logTrade(`üìà ${action} th·ªß c√¥ng @ ${entryPrice.toFixed(2)} | SL: ${stopLoss.toFixed(2)} | TP: ${takeProfit.toFixed(2)}`);
            
            saveData();
        }

        function recordTradePattern(trade, reason) {
            const pattern = analyzeCurrentMarketPattern();
            
            const tradeRecord = {
                id: Date.now(),
                timestamp: new Date(),
                pattern: pattern,
                action: trade.action,
                entryPrice: trade.entryPrice,
                stopLoss: trade.stopLoss,
                takeProfit: trade.takeProfit,
                lotSize: trade.lotSize,
                leverage: trade.leverage,
                reason: reason,
                outcome: 'PENDING',
                confidence: calculatePatternConfidence(pattern)
            };
            
            learnedPatterns.push(tradeRecord);
            updatePatternsDisplay();
            updateLearningStats();
            
            console.log('üìù ƒê√£ ghi nh·∫≠n pattern:', tradeRecord);
        }

        function analyzeCurrentMarketPattern() {
            const rsi = calculateRSI(14);
            const macd = calculateMACD();
            const ema20 = calculateEMA(20);
            const ema50 = calculateEMA(50);
            const trend = getMarketTrend();
            
            let patternType = 'MIXED_SIGNAL';
            
            // Ph√¢n t√≠ch pattern d·ª±a tr√™n indicators
            if (rsi < 30) patternType = 'OVERSOLD';
            else if (rsi > 70) patternType = 'OVERBOUGHT';
            else if (currentPrice < ema20 && trend === 'DOWN') patternType = 'TREND_CONTINUATION';
            else if (currentPrice > ema20 && trend === 'UP') patternType = 'TREND_CONTINUATION';
            else if (macd.histogram > 0 && rsi > 50) patternType = 'BULLISH';
            else if (macd.histogram < 0 && rsi < 50) patternType = 'BEARISH';
            
            return {
                type: patternType,
                rsi: rsi,
                macd: macd.histogram,
                ema20: ema20,
                ema50: ema50,
                trend: trend,
                price: currentPrice,
                timestamp: new Date()
            };
        }

        function getMarketTrend() {
            if (priceHistory.length < 20) return 'SIDEWAYS';
            
            const recentPrices = priceHistory.slice(-20);
            const first = recentPrices[0].price;
            const last = recentPrices[recentPrices.length - 1].price;
            const change = ((last - first) / first) * 100;
            
            if (Math.abs(change) < 0.5) return 'SIDEWAYS';
            return change > 0 ? 'UP' : 'DOWN';
        }

        function calculatePatternConfidence(pattern) {
            // T√¨m c√°c pattern t∆∞∆°ng t·ª±
            const similarPatterns = findSimilarPatterns(pattern);
            
            if (similarPatterns.length === 0) return 50;
            
            // T√≠nh win rate c·ªßa c√°c pattern t∆∞∆°ng t·ª±
            const completed = similarPatterns.filter(p => p.outcome !== 'PENDING');
            if (completed.length === 0) return 50;
            
            const wins = completed.filter(p => p.outcome === 'WIN').length;
            const winRate = (wins / completed.length) * 100;
            
            return Math.min(winRate, 95);
        }

        function findSimilarPatterns(currentPattern, minSimilarity = 0.7) {
            return learnedPatterns.filter(pattern => {
                const similarity = calculatePatternSimilarity(pattern.pattern, currentPattern);
                return similarity >= minSimilarity;
            });
        }

        function calculatePatternSimilarity(p1, p2) {
            let score = 0;
            
            // So s√°nh lo·∫°i pattern
            if (p1.type === p2.type) score += 0.3;
            
            // So s√°nh RSI (trong kho·∫£ng ¬±10)
            const rsiDiff = Math.abs(p1.rsi - p2.rsi);
            if (rsiDiff < 5) score += 0.3;
            else if (rsiDiff < 10) score += 0.2;
            else if (rsiDiff < 15) score += 0.1;
            
            // So s√°nh trend
            if (p1.trend === p2.trend) score += 0.2;
            
            // So s√°nh v·ªã tr√≠ gi√° so v·ªõi EMA
            const emaRelation1 = p1.price > p1.ema20;
            const emaRelation2 = p2.price > p2.ema20;
            if (emaRelation1 === emaRelation2) score += 0.2;
            
            return score;
        }

        function checkOpenTrades() {
            currentTrades.forEach((trade, index) => {
                if (trade.status === 'OPEN') {
                    let closeReason = '';
                    
                    if (trade.action === 'BUY') {
                        if (currentPrice <= trade.stopLoss) closeReason = 'STOP_LOSS';
                        else if (currentPrice >= trade.takeProfit) closeReason = 'TAKE_PROFIT';
                    } else {
                        if (currentPrice >= trade.stopLoss) closeReason = 'STOP_LOSS';
                        else if (currentPrice <= trade.takeProfit) closeReason = 'TAKE_PROFIT';
                    }
                    
                    if (closeReason) {
                        closeTrade(trade, closeReason);
                    }
                }
            });
        }

        function closeTrade(trade, reason) {
            // T√≠nh l·ª£i nhu·∫≠n
            let profit = 0;
            if (trade.action === 'BUY') {
                profit = (currentPrice - trade.entryPrice) * trade.lotSize * trade.leverage * 100;
            } else {
                profit = (trade.entryPrice - currentPrice) * trade.lotSize * trade.leverage * 100;
            }
            
            // C·∫≠p nh·∫≠t trade
            trade.status = 'CLOSED';
            trade.closePrice = currentPrice;
            trade.closeTime = new Date();
            trade.closeReason = reason;
            trade.profit = profit;
            
            // C·∫≠p nh·∫≠t s·ªë d∆∞
            virtualBalance += profit;
            
            // C·∫≠p nh·∫≠t pattern outcome n·∫øu c√≥
            if (trade.learnedPatternId) {
                updatePatternOutcome(trade.learnedPatternId, profit > 0 ? 'WIN' : 'LOSS', profit);
            }
            
            // Ph√°t √¢m thanh
            playSound(profit > 0 ? 'tp' : 'sl');
            
            // Log
            const profitText = profit >= 0 ? 
                `<span class="profit">+${profit.toFixed(2)} USD</span>` : 
                `<span class="loss">${profit.toFixed(2)} USD</span>`;
            
            logTrade(`üîî ƒê√≥ng ${trade.action}: ${reason} @ ${currentPrice.toFixed(2)} | L·ª£i nhu·∫≠n: ${profitText}`);
            
            // C·∫≠p nh·∫≠t giao di·ªán
            updateTradeDisplay();
            updateStatusBar();
            updateChartOnTrade(profit, trade.action, reason);
            
            // TƒÉng s·ªë trade h√¥m nay
            tradesToday++;
            
            saveData();
        }

        function closeAllTrades() {
            if (currentTrades.length === 0) {
                showNotification('‚ö†Ô∏è Kh√¥ng c√≥ l·ªánh n√†o ƒëang m·ªü', 'warning');
                return;
            }
            
            if (!confirm(`ƒê√≥ng t·∫•t c·∫£ ${currentTrades.length} l·ªánh ƒëang m·ªü?`)) return;
            
            currentTrades.forEach(trade => {
                if (trade.status === 'OPEN') {
                    closeTrade(trade, 'MANUAL_CLOSE');
                }
            });
            
            showNotification(`‚úÖ ƒê√£ ƒë√≥ng t·∫•t c·∫£ l·ªánh`, 'success');
        }

        // ==================== LEARNING SYSTEM ====================
        function changeTradingMode() {
            const mode = document.getElementById('tradingMode').value;
            tradingMode = mode;
            
            let message = '';
            switch(mode) {
                case 'manual':
                    message = 'üë®‚Äçüíº Ch·∫ø ƒë·ªô Th·ªß C√¥ng: B·∫°n t·ª± quy·∫øt ƒë·ªãnh m·ªçi giao d·ªãch';
                    break;
                case 'learning':
                    message = 'üìö Ch·∫ø ƒë·ªô H·ªçc T·∫≠p: H·ªá th·ªëng ƒëang h·ªçc c√°ch b·∫°n trade';
                    break;
                case 'suggestion':
                    message = 'üí° Ch·∫ø ƒë·ªô ƒê·ªÅ Xu·∫•t: H·ªá th·ªëng s·∫Ω g·ª£i √Ω khi ph√°t hi·ªán setup t∆∞∆°ng t·ª±';
                    break;
                case 'auto':
                    message = 'ü§ñ Ch·∫ø ƒë·ªô T·ª± ƒê·ªông: H·ªá th·ªëng s·∫Ω t·ª± trade v·ªõi setup c√≥ ƒë·ªô tin c·∫≠y cao';
                    break;
            }
            
            showNotification(message, 'success');
            updateStatusBar();
            saveData();
        }

        function startLearningMode() {
            tradingMode = 'learning';
            document.getElementById('tradingMode').value = 'learning';
            showNotification('üìö ƒê√£ b·∫≠t ch·∫ø ƒë·ªô h·ªçc t·∫≠p. H√£y trade th·ªß c√¥ng ƒë·ªÉ h·ªá th·ªëng h·ªçc h·ªèi!', 'success');
            saveData();
        }

        function checkTradingOpportunities() {
            if (tradingMode !== 'suggestion' && tradingMode !== 'auto') return;
            
            const pattern = analyzeCurrentMarketPattern();
            const similarPatterns = findSimilarPatterns(pattern, 0.6);
            
            if (similarPatterns.length === 0) return;
            
            const confidence = calculatePatternConfidence(pattern);
            const minConfidence = parseInt(document.getElementById('minConfidence').value);
            
            if (confidence >= minConfidence) {
                const bestPattern = getBestPattern(similarPatterns);
                
                if (tradingMode === 'suggestion') {
                    showTradingSuggestion(bestPattern, confidence);
                } else if (tradingMode === 'auto') {
                    executeAutoTrade(bestPattern, confidence);
                }
            }
        }

        function getBestPattern(patterns) {
            return patterns.reduce((best, current) => {
                const bestScore = (best.confidence || 0) + (best.outcome === 'WIN' ? 20 : 0);
                const currentScore = (current.confidence || 0) + (current.outcome === 'WIN' ? 20 : 0);
                return currentScore > bestScore ? current : best;
            });
        }

        function showTradingSuggestion(pattern, confidence) {
            // Ki·ªÉm tra xem ƒë√£ c√≥ suggestion ch∆∞a
            if (document.querySelector('#suggestionsContainer .notification')) return;
            
            const suggestionHTML = `
                <div class="notification success" style="animation: pulse 2s infinite;">
                    <strong>üí° G·ª¢I √ù GIAO D·ªäCH (${confidence.toFixed(1)}% tin c·∫≠y)</strong>
                    <p>üìä Setup: ${PATTERN_TYPES[pattern.pattern.type]?.name || pattern.pattern.type}</p>
                    <p>üéØ H√†nh ƒë·ªông tr∆∞·ªõc: ${pattern.action}</p>
                    <p>üìà K·∫øt qu·∫£: ${pattern.outcome === 'WIN' ? '‚úÖ Th·∫Øng' : pattern.outcome === 'LOSS' ? '‚ùå Thua' : '‚è≥ ƒêang ch·ªù'}</p>
                    <p>üí∞ Entry: ${pattern.entryPrice.toFixed(2)} | SL: ${pattern.stopLoss.toFixed(2)} | TP: ${pattern.takeProfit.toFixed(2)}</p>
                    <div style="margin-top: 15px; display: flex; gap: 10px;">
                        <button onclick="acceptSuggestion(${pattern.id})" style="padding: 8px 15px;" class="success">‚úÖ ƒê·ªíNG √ù</button>
                        <button onclick="ignoreSuggestion(${pattern.id})" style="padding: 8px 15px;" class="danger">‚ùå B·ªé QUA</button>
                    </div>
                </div>
            `;
            
            document.getElementById('suggestionsContainer').innerHTML = suggestionHTML;
            playSound('suggestion');
        }

        function acceptSuggestion(patternId) {
            const pattern = learnedPatterns.find(p => p.id === patternId);
            if (!pattern) return;
            
            // T·∫°o trade d·ª±a tr√™n pattern
            const trade = {
                id: Date.now(),
                action: pattern.action,
                entryPrice: currentPrice,
                stopLoss: pattern.stopLoss,
                takeProfit: pattern.takeProfit,
                lotSize: pattern.lotSize,
                leverage: pattern.leverage,
                status: 'OPEN',
                openTime: new Date(),
                type: 'SUGGESTION',
                learnedPatternId: patternId
            };
            
            currentTrades.push(trade);
            updateTradeDisplay();
            playSound('open');
            
            document.getElementById('suggestionsContainer').innerHTML = '';
            showNotification(`‚úÖ ƒê√£ v√†o l·ªánh ${pattern.action} theo ƒë·ªÅ xu·∫•t`, 'success');
            
            logTrade(`ü§ñ ${pattern.action} theo ƒë·ªÅ xu·∫•t @ ${currentPrice.toFixed(2)}`);
            
            saveData();
        }

        function ignoreSuggestion(patternId) {
            document.getElementById('suggestionsContainer').innerHTML = '';
            logTrade('ƒê√£ b·ªè qua ƒë·ªÅ xu·∫•t giao d·ªãch');
        }

        function executeAutoTrade(pattern, confidence) {
            // Ki·ªÉm tra ƒëi·ªÅu ki·ªán auto-trade
            if (!canAutoTrade()) return;
            
            // Ki·ªÉm tra kh√¥ng tr√πng l·ªánh
            const hasSimilarTrade = currentTrades.some(t => 
                t.status === 'OPEN' && 
                t.action === pattern.action &&
                Math.abs(t.entryPrice - currentPrice) < 2
            );
            
            if (hasSimilarTrade) return;
            
            // T·∫°o trade
            const trade = {
                id: Date.now(),
                action: pattern.action,
                entryPrice: currentPrice,
                stopLoss: pattern.stopLoss,
                takeProfit: pattern.takeProfit,
                lotSize: pattern.lotSize,
                leverage: pattern.leverage,
                status: 'OPEN',
                openTime: new Date(),
                type: 'AUTO',
                learnedPatternId: pattern.id
            };
            
            currentTrades.push(trade);
            updateTradeDisplay();
            playSound('open');
            
            logTrade(`ü§ñ AUTO ${pattern.action} @ ${currentPrice.toFixed(2)} (${confidence.toFixed(1)}% tin c·∫≠y)`);
            
            saveData();
        }

        function canAutoTrade() {
            const minSamples = parseInt(document.getElementById('minSamples').value);
            const completedPatterns = learnedPatterns.filter(p => p.outcome !== 'PENDING');
            
            if (completedPatterns.length < minSamples) return false;
            
            const wins = completedPatterns.filter(p => p.outcome === 'WIN').length;
            const winRate = wins / completedPatterns.length;
            
            return winRate >= 0.6; // C·∫ßn √≠t nh·∫•t 60% win rate
        }

        function updatePatternOutcome(patternId, outcome, profit) {
            const pattern = learnedPatterns.find(p => p.id === patternId);
            if (pattern) {
                pattern.outcome = outcome;
                pattern.profit = profit;
                pattern.closeTime = new Date();
                updatePatternsDisplay();
                updateLearningStats();
            }
        }

        // ==================== UI UPDATES ====================
        function updateAllDisplays() {
            updateStatusBar();
            updateTradeDisplay();
            updatePatternsDisplay();
            updateLearningStats();
            updateChart();
        }

        function updateStatusBar() {
            document.getElementById('balanceText').textContent = `$${virtualBalance.toFixed(2)}`;
            document.getElementById('balanceText').className = virtualBalance >= 1000 ? 'status-value profit' : 'status-value loss';
            document.getElementById('tradesCount').textContent = tradesToday;
            document.getElementById('openTradesCount').textContent = currentTrades.filter(t => t.status === 'OPEN').length;
            document.getElementById('patternsCount').textContent = learnedPatterns.length;
            
            // Update mode text
            const modeText = document.getElementById('modeText');
            switch(tradingMode) {
                case 'manual': modeText.textContent = 'Th·ªß C√¥ng'; break;
                case 'learning': modeText.textContent = 'H·ªçc T·∫≠p'; break;
                case 'suggestion': modeText.textContent = 'ƒê·ªÅ Xu·∫•t'; break;
                case 'auto': modeText.textContent = 'T·ª± ƒê·ªông'; break;
            }
        }

        function updateTradeDisplay() {
            const container = document.getElementById('tradeBoxes');
            const detailsContainer = document.getElementById('currentTradeDetails');
            
            if (currentTrades.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.7;">Kh√¥ng c√≥ l·ªánh n√†o ƒëang m·ªü</div>';
                detailsContainer.style.display = 'none';
                return;
            }
            
            detailsContainer.style.display = 'block';
            container.innerHTML = '';
            
            // Hi·ªÉn th·ªã c√°c trade m·ªõi nh·∫•t tr∆∞·ªõc
            currentTrades.slice().reverse().forEach(trade => {
                const profit = trade.status === 'OPEN' ? 
                    calculateFloatingProfit(trade) : 
                    trade.profit || 0;
                
                const profitClass = profit >= 0 ? 'profit' : 'loss';
                const statusClass = trade.status === 'OPEN' ? '' : 'closed';
                
                const tradeBox = document.createElement('div');
                tradeBox.className = `trade-box ${trade.action.toLowerCase()} ${statusClass}`;
                tradeBox.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                        <h3 style="margin: 0;">${trade.action} ${trade.status === 'OPEN' ? 'üü¢' : 'üî¥'}</h3>
                        <span class="badge ${trade.type === 'AUTO' ? 'info' : trade.type === 'SUGGESTION' ? 'warning' : 'success'}">
                            ${trade.type}
                        </span>
                    </div>
                    <p>üìÖ V√†o: ${trade.openTime.toLocaleTimeString('vi-VN')}</p>
                    <p>üí∞ Entry: ${trade.entryPrice.toFixed(2)}</p>
                    <p>üéØ Hi·ªán t·∫°i: ${currentPrice.toFixed(2)}</p>
                    <p>üìä L·ª£i nhu·∫≠n: <span class="${profitClass}">${profit.toFixed(2)} USD</span></p>
                    <p>üõ°Ô∏è SL: ${trade.stopLoss.toFixed(2)}</p>
                    <p>üéØ TP: ${trade.takeProfit.toFixed(2)}</p>
                    ${trade.status === 'CLOSED' ? 
                        `<p>üîö L√Ω do: ${trade.closeReason} @ ${trade.closePrice.toFixed(2)}</p>` : 
                        `<p>‚è±Ô∏è Th·ªùi gian: ${Math.floor((new Date() - trade.openTime) / 60000)} ph√∫t</p>`
                    }
                `;
                
                container.appendChild(tradeBox);
            });
        }

        function calculateFloatingProfit(trade) {
            if (trade.action === 'BUY') {
                return (currentPrice - trade.entryPrice) * trade.lotSize * trade.leverage * 100;
            } else {
                return (trade.entryPrice - currentPrice) * trade.lotSize * trade.leverage * 100;
            }
        }

        function updatePatternsDisplay() {
            const container = document.getElementById('patternsList');
            
            if (learnedPatterns.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 20px; opacity: 0.7;">Ch∆∞a c√≥ m·∫´u h√¨nh n√†o ƒë∆∞·ª£c h·ªçc</div>';
                return;
            }
            
            // Nh√≥m patterns theo type
            const patternsByType = {};
            learnedPatterns.forEach(pattern => {
                const type = pattern.pattern.type;
                if (!patternsByType[type]) patternsByType[type] = [];
                patternsByType[type].push(pattern);
            });
            
            let html = '';
            for (const [type, patterns] of Object.entries(patternsByType)) {
                const wins = patterns.filter(p => p.outcome === 'WIN').length;
                const completed = patterns.filter(p => p.outcome !== 'PENDING').length;
                const winRate = completed > 0 ? Math.round((wins / completed) * 100) : 0;
                
                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background: rgba(40, 40, 50, 0.5); border-radius: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <strong>${PATTERN_TYPES[type]?.name || type}</strong>
                            <span>${patterns.length} m·∫´u</span>
                        </div>
                        <div style="display: flex; gap: 10px; font-size: 0.9rem;">
                            <span class="${winRate >= 60 ? 'profit' : 'loss'}">${winRate}% Win Rate</span>
                            <span>${completed} ƒë√£ ho√†n th√†nh</span>
                        </div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function updateLearningStats() {
            const total = learnedPatterns.length;
            const completed = learnedPatterns.filter(p => p.outcome !== 'PENDING').length;
            const wins = learnedPatterns.filter(p => p.outcome === 'WIN').length;
            const winRate = completed > 0 ? Math.round((wins / completed) * 100) : 0;
            
            // T√≠nh ƒë·ªô tin c·∫≠y trung b√¨nh
            const avgConfidence = total > 0 ? 
                Math.round(learnedPatterns.reduce((sum, p) => sum + (p.confidence || 50), 0) / total) : 0;
            
            document.getElementById('totalPatterns').textContent = total;
            document.getElementById('winRate').textContent = `${winRate}% Win Rate`;
            document.getElementById('avgConfidence').textContent = `${avgConfidence}% Tin c·∫≠y`;
            
            // T√¨m pattern t·ªët nh·∫•t
            if (completed > 0) {
                const bestPattern = learnedPatterns.reduce((best, current) => {
                    if (current.outcome === 'WIN') {
                        const bestScore = best ? (best.confidence || 0) : 0;
                        const currentScore = current.confidence || 0;
                        return currentScore > bestScore ? current : best;
                    }
                    return best;
                }, null);
                
                if (bestPattern) {
                    document.getElementById('bestPattern').textContent = 
                        `${PATTERN_TYPES[bestPattern.pattern.type]?.name || bestPattern.pattern.type}`;
                    document.getElementById('bestPatternStats').textContent = 
                        `T·ªâ l·ªá th·∫Øng: ${Math.round(bestPattern.confidence || 0)}%`;
                }
            }
            
            // Update system status
            const statusElement = document.getElementById('systemStatus');
            const autoTradeStatus = document.getElementById('autoTradeStatus');
            
            if (tradingMode === 'auto') {
                statusElement.textContent = canAutoTrade() ? 'üü¢ AUTO-TRADE S·∫¥N S√ÄNG' : 'üü° ƒêANG H·ªåC';
                statusElement.style.color = canAutoTrade() ? '#2ecc71' : '#f39c12';
                autoTradeStatus.style.display = 'block';
            } else {
                statusElement.textContent = 'üü¢ ƒêANG HO·∫†T ƒê·ªòNG';
                statusElement.style.color = '#2ecc71';
                autoTradeStatus.style.display = 'none';
            }
        }

        // ==================== CHART FUNCTIONS ====================
        function initChart() {
            const ctx = document.getElementById('mainChart').getContext('2d');
            
            mainChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'S·ªë D∆∞ (USD)',
                            data: [],
                            borderColor: '#2ecc71',
                            backgroundColor: 'rgba(46, 204, 113, 0.1)',
                            tension: 0.2,
                            yAxisID: 'y-balance',
                            borderWidth: 2
                        },
                        {
                            label: 'Gi√° V√†ng (USD)',
                            data: [],
                            borderColor: '#d4af37',
                            backgroundColor: 'rgba(212, 175, 55, 0.1)',
                            tension: 0.2,
                            yAxisID: 'y-gold',
                            borderWidth: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#e6e6e6' }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#b0b0b0' },
                            grid: { color: 'rgba(100, 100, 120, 0.2)' }
                        },
                        'y-balance': {
                            type: 'linear',
                            position: 'left',
                            ticks: { color: '#2ecc71' },
                            grid: { color: 'rgba(46, 204, 113, 0.1)' },
                            title: {
                                display: true,
                                text: 'S·ªë D∆∞ (USD)',
                                color: '#2ecc71'
                            }
                        },
                        'y-gold': {
                            type: 'linear',
                            position: 'right',
                            ticks: { color: '#d4af37' },
                            grid: { drawOnChartArea: false },
                            title: {
                                display: true,
                                text: 'Gi√° V√†ng (USD)',
                                color: '#d4af37'
                            }
                        }
                    }
                }
            });
        }

        function updateChart() {
            if (!mainChart) return;
            
            // Update with recent data (last 50 points)
            const recentBalance = balanceHistory.slice(-50);
            const recentPrice = priceHistory.slice(-50);
            
            mainChart.data.labels = recentPrice.map((p, i) => 
                p.timestamp.toLocaleTimeString('vi-VN').substring(0, 5)
            );
            mainChart.data.datasets[0].data = recentBalance.map(b => b.balance);
            mainChart.data.datasets[1].data = recentPrice.map(p => p.price);
            
            mainChart.update('none');
        }

        function updateChartOnTrade(profit, action, reason) {
            balanceHistory.push({
                timestamp: new Date(),
                balance: virtualBalance,
                profit: profit,
                action: action,
                reason: reason
            });
            
            if (balanceHistory.length > 100) balanceHistory.shift();
            updateChart();
        }

        function toggleChartType() {
            if (!mainChart) return;
            
            const newType = mainChart.config.type === 'line' ? 'bar' : 'line';
            mainChart.config.type = newType;
            mainChart.update();
            
            showNotification(`üìä ƒê√£ ƒë·ªïi sang bi·ªÉu ƒë·ªì ${newType === 'line' ? 'ƒë∆∞·ªùng' : 'c·ªôt'}`, 'success');
        }

        // ==================== UTILITY FUNCTIONS ====================
        function logTrade(message) {
            const historyList = document.getElementById('historyList');
            const now = new Date();
            const timeStr = now.toLocaleTimeString('vi-VN');
            
            const item = document.createElement('div');
            item.className = 'history-item';
            item.innerHTML = `<strong>${timeStr}:</strong> ${message}`;
            
            historyList.insertBefore(item, historyList.firstChild);
            
            if (historyList.children.length > 50) {
                historyList.removeChild(historyList.lastChild);
            }
        }

        function showNotification(message, type = 'info') {
            logTrade(message);
            
            // Create toast notification
            const toast = document.createElement('div');
            toast.className = `notification ${type}`;
            toast.textContent = message;
            toast.style.position = 'fixed';
            toast.style.top = '20px';
            toast.style.left = '50%';
            toast.style.transform = 'translateX(-50%)';
            toast.style.zIndex = '1000';
            toast.style.maxWidth = '80%';
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 5000);
        }

        function playSound(soundName) {
            if (useGlobalSound) return;
            
            const sound = sounds[soundName];
            if (sound) {
                sound.currentTime = 0;
                sound.volume = soundVolume / 100;
                sound.play().catch(e => console.log('Kh√¥ng th·ªÉ ph√°t √¢m thanh:', e));
            }
        }

        function setupEventListeners() {
            // Confidence slider
            const confidenceSlider = document.getElementById('minConfidence');
            const confidenceValue = document.getElementById('confidenceValue');
            confidenceSlider.addEventListener('input', function() {
                confidenceValue.textContent = this.value + '%';
            });
            
            // Volume slider
            const volumeSlider = document.getElementById('soundVolume');
            const volumeValue = document.getElementById('volumeValue');
            volumeSlider.addEventListener('input', function() {
                soundVolume = this.value;
                volumeValue.textContent = soundVolume + '%';
                Object.values(sounds).forEach(sound => {
                    sound.volume = soundVolume / 100;
                });
            });
            
            // Balance input
            document.getElementById('virtualBalance').addEventListener('change', function() {
                virtualBalance = parseFloat(this.value);
                updateStatusBar();
            });
        }

        function startIntervals() {
            // Ki·ªÉm tra trade m·ªói gi√¢y
            setInterval(checkOpenTrades, 1000);
            
            // Ki·ªÉm tra c∆° h·ªôi giao d·ªãch m·ªói 30 gi√¢y
            setInterval(checkTradingOpportunities, 30000);
            
            // T·ª± ƒë·ªông save m·ªói ph√∫t
            setInterval(saveData, 60000);
        }

        // ==================== DATA MANAGEMENT ====================
        function analyzeMyStrategy() {
            if (learnedPatterns.length === 0) {
                showNotification('üìä Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch', 'warning');
                return;
            }
            
            const completed = learnedPatterns.filter(p => p.outcome !== 'PENDING');
            const wins = completed.filter(p => p.outcome === 'WIN').length;
            const winRate = completed.length > 0 ? (wins / completed.length * 100).toFixed(1) : 0;
            
            // Ph√¢n t√≠ch theo pattern type
            const patternAnalysis = {};
            completed.forEach(pattern => {
                const type = pattern.pattern.type;
                if (!patternAnalysis[type]) {
                    patternAnalysis[type] = { total: 0, wins: 0, totalProfit: 0 };
                }
                patternAnalysis[type].total++;
                if (pattern.outcome === 'WIN') patternAnalysis[type].wins++;
                patternAnalysis[type].totalProfit += pattern.profit || 0;
            });
            
            let analysis = `üìä PH√ÇN T√çCH CHI·∫æN L∆Ø·ª¢C\n`;
            analysis += `========================\n`;
            analysis += `‚Ä¢ T·ªïng m·∫´u: ${learnedPatterns.length}\n`;
            analysis += `‚Ä¢ ƒê√£ ho√†n th√†nh: ${completed.length}\n`;
            analysis += `‚Ä¢ Win rate t·ªïng: ${winRate}%\n\n`;
            analysis += `üìà PH√ÇN T√çCH THEO LO·∫†I:\n`;
            
            for (const [type, stats] of Object.entries(patternAnalysis)) {
                const typeWinRate = (stats.wins / stats.total * 100).toFixed(1);
                const avgProfit = (stats.totalProfit / stats.total).toFixed(2);
                analysis += `\n${PATTERN_TYPES[type]?.name || type}:\n`;
                analysis += `  ‚Ä¢ S·ªë l·ªánh: ${stats.total}\n`;
                analysis += `  ‚Ä¢ Win rate: ${typeWinRate}%\n`;
                analysis += `  ‚Ä¢ L·ª£i nhu·∫≠n TB: ${avgProfit} USD\n`;
            }
            
            alert(analysis);
            showNotification('üìä ƒê√£ ph√¢n t√≠ch chi·∫øn l∆∞·ª£c th√†nh c√¥ng', 'success');
        }

        function exportLearningData() {
            if (learnedPatterns.length === 0) {
                showNotification('‚ö†Ô∏è Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t', 'error');
                return;
            }
            
            const data = JSON.stringify(learnedPatterns, null, 2);
            const blob = new Blob([data], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `trading_data_${new Date().toISOString().slice(0, 10)}.json`;
            a.click();
            
            showNotification('üíæ ƒê√£ xu·∫•t d·ªØ li·ªáu h·ªçc t·∫≠p', 'success');
        }

        function exportTradeHistory() {
            const history = balanceHistory.map(item => ({
                time: item.timestamp.toISOString(),
                balance: item.balance,
                profit: item.profit,
                action: item.action,
                reason: item.reason
            }));
            
            if (history.length === 0) {
                showNotification('‚ö†Ô∏è Kh√¥ng c√≥ l·ªãch s·ª≠ giao d·ªãch', 'error');
                return;
            }
            
            const csv = [
                ['Th·ªùi Gian', 'S·ªë D∆∞', 'L·ª£i Nhu·∫≠n', 'Lo·∫°i L·ªánh', 'L√Ω Do'],
                ...history.map(h => [h.time, h.balance, h.profit, h.action, h.reason])
            ].map(row => row.join(',')).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `trade_history_${new Date().toISOString().slice(0, 10)}.csv`;
            a.click();
            
            showNotification('üíæ ƒê√£ xu·∫•t l·ªãch s·ª≠ giao d·ªãch', 'success');
        }

        function clearLearningData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a T·∫§T C·∫¢ d·ªØ li·ªáu h·ªçc t·∫≠p? H√†nh ƒë·ªông n√†y kh√¥ng th·ªÉ ho√†n t√°c.')) {
                return;
            }
            
            learnedPatterns = [];
            localStorage.removeItem('learnedPatterns');
            updatePatternsDisplay();
            updateLearningStats();
            
            showNotification('üóëÔ∏è ƒê√£ x√≥a to√†n b·ªô d·ªØ li·ªáu h·ªçc t·∫≠p', 'success');
        }

        function clearTradeHistory() {
            if (!confirm('X√≥a l·ªãch s·ª≠ giao d·ªãch?')) return;
            
            document.getElementById('historyList').innerHTML = '';
            balanceHistory = [];
            showNotification('üßπ ƒê√£ x√≥a l·ªãch s·ª≠ giao d·ªãch', 'success');
        }

        function resetAll() {
            if (!confirm('RESET TO√ÄN B·ªò H·ªÜ TH·ªêNG?\n\nT·∫•t c·∫£ d·ªØ li·ªáu s·∫Ω b·ªã x√≥a v√† h·ªá th·ªëng s·∫Ω tr·ªü v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu.')) {
                return;
            }
            
            virtualBalance = 1000;
            tradesToday = 0;
            currentTrades = [];
            learnedPatterns = [];
            priceHistory = [];
            balanceHistory = [];
            
            localStorage.clear();
            
            document.getElementById('virtualBalance').value = 1000;
            document.getElementById('lotSize').value = 0.1;
            document.getElementById('leverage').value = 10;
            document.getElementById('stopLoss').value = 50;
            document.getElementById('takeProfit').value = 65;
            document.getElementById('tradingMode').value = 'manual';
            
            updateAllDisplays();
            showNotification('üîÑ ƒê√£ reset to√†n b·ªô h·ªá th·ªëng', 'success');
        }

        // ==================== PRICE ALERTS ====================
        function setupPriceAlerts() {
            const input = document.getElementById('alertPrices').value;
            if (!input.trim()) {
                showNotification('‚ö†Ô∏è Vui l√≤ng nh·∫≠p c√°c m·ªëc gi√°', 'error');
                return;
            }
            
            alertLevels = input.split(',')
                .map(p => parseFloat(p.trim()))
                .filter(p => !isNaN(p) && p > 0);
            
            alertedLevels.clear();
            
            // Update alerts list
            const alertsList = document.getElementById('alertsList');
            alertsList.innerHTML = alertLevels.map(level => `
                <div style="padding: 8px; margin: 5px 0; background: rgba(52, 152, 219, 0.1); border-radius: 6px;">
                    üîî ${level.toFixed(2)} USD
                </div>
            `).join('');
            
            showNotification(`‚úÖ ƒê√£ thi·∫øt l·∫≠p ${alertLevels.length} m·ªëc c·∫£nh b√°o`, 'success');
        }

        function checkPriceAlerts(currentPrice) {
            if (alertLevels.length === 0) return;
            
            alertLevels.forEach(level => {
                if (alertedLevels.has(level)) return;
                
                if (Math.abs(currentPrice - level) < 0.5) {
                    alertedLevels.add(level);
                    playSound('alert');
                    showNotification(`üì¢ Gi√° ƒë√£ ch·∫°m m·ªëc ${level.toFixed(2)} USD!`, 'warning');
                }
            });
        }

        function clearAlerts() {
            alertLevels = [];
            alertedLevels.clear();
            document.getElementById('alertsList').innerHTML = '';
            document.getElementById('alertPrices').value = '';
            showNotification('üóëÔ∏è ƒê√£ x√≥a t·∫•t c·∫£ c·∫£nh b√°o', 'success');
        }

        // ==================== SOUND SETTINGS ====================
        function saveSoundSettings() {
            useGlobalSound = document.getElementById('useGlobalSound').checked;
            soundVolume = parseInt(document.getElementById('soundVolume').value);
            
            // Save sound files if selected
            const soundInputs = ['openSoundInput', 'tpSoundInput', 'slSoundInput', 'suggestionSoundInput', 'alertSoundInput'];
            soundInputs.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input.files.length > 0) {
                    const soundName = inputId.replace('SoundInput', '');
                    sounds[soundName] = new Audio(URL.createObjectURL(input.files[0]));
                }
            });
            
            saveData();
            showNotification('üîä ƒê√£ l∆∞u c√†i ƒë·∫∑t √¢m thanh', 'success');
        }

        function testAllSounds() {
            Object.entries(sounds).forEach(([name, sound], index) => {
                setTimeout(() => {
                    playSound(name);
                    showNotification(`‚ñ∂Ô∏è ƒêang ph√°t: ${name}`, 'info');
                }, index * 1000);
            });
        }

        function resetSoundSettings() {
            if (!confirm('Reset c√†i ƒë·∫∑t √¢m thanh v·ªÅ m·∫∑c ƒë·ªãnh?')) return;
            
            // Reset to default sounds
            sounds = {
                open: new Audio('https://assets.mixkit.co/active_storage/sfx/286/286-preview.mp3'),
                tp: new Audio('https://assets.mixkit.co/active_storage/sfx/257/257-preview.mp3'),
                sl: new Audio('https://assets.mixkit.co/active_storage/sfx/255/255-preview.mp3'),
                suggestion: new Audio('https://assets.mixkit.co/active_storage/sfx/286/286-preview.mp3'),
                alert: new Audio('https://assets.mixkit.co/active_storage/sfx/250/250-preview.mp3')
            };
            
            useGlobalSound = false;
            soundVolume = 50;
            
            document.getElementById('useGlobalSound').checked = false;
            document.getElementById('soundVolume').value = 50;
            document.getElementById('volumeValue').textContent = '50%';
            
            // Clear file inputs
            const soundInputs = ['openSoundInput', 'tpSoundInput', 'slSoundInput', 'suggestionSoundInput', 'alertSoundInput'];
            soundInputs.forEach(id => {
                document.getElementById(id).value = '';
            });
            
            showNotification('üîä ƒê√£ reset c√†i ƒë·∫∑t √¢m thanh', 'success');
        }

        // ==================== MODAL FUNCTIONS ====================
        function showAdvancedSettings() {
            document.getElementById('advancedSettingsModal').style.display = 'flex';
        }

        function closeAdvancedSettings() {
            document.getElementById('advancedSettingsModal').style.display = 'none';
        }

        function saveAdvancedSettings() {
            // Save advanced settings here
            closeAdvancedSettings();
            showNotification('‚öôÔ∏è ƒê√£ l∆∞u c√†i ƒë·∫∑t n√¢ng cao', 'success');
        }

        function showChartSettings() {
            alert('C√†i ƒë·∫∑t bi·ªÉu ƒë·ªì:\n\n‚Ä¢ ƒêang s·ª≠ d·ª•ng d·ªØ li·ªáu th·ªùi gian th·ª±c\n‚Ä¢ T·ª± ƒë·ªông c·∫≠p nh·∫≠t m·ªói khi c√≥ gi√° m·ªõi\n‚Ä¢ Hi·ªÉn th·ªã 50 ƒëi·ªÉm d·ªØ li·ªáu g·∫ßn nh·∫•t');
        }

        function updateChartData() {
            updateChart();
            showNotification('üîÑ ƒê√£ c·∫≠p nh·∫≠t d·ªØ li·ªáu bi·ªÉu ƒë·ªì', 'success');
        }

        function clearChart() {
            if (!confirm('X√≥a d·ªØ li·ªáu bi·ªÉu ƒë·ªì?')) return;
            
            balanceHistory = [];
            updateChart();
            showNotification('üóëÔ∏è ƒê√£ x√≥a d·ªØ li·ªáu bi·ªÉu ƒë·ªì', 'success');
        }

        // ==================== INITIALIZE ====================
        window.onload = initializeSystem;
        
        // Auto-save khi ƒë√≥ng tab
        window.addEventListener('beforeunload', saveData);
        
        // Prevent accidental page reload
        window.addEventListener('beforeunload', (e) => {
            if (currentTrades.some(t => t.status === 'OPEN')) {
                e.preventDefault();
                e.returnValue = 'B·∫°n c√≥ l·ªánh ƒëang m·ªü. B·∫°n c√≥ ch·∫Øc mu·ªën tho√°t?';
                return e.returnValue;
            }
        });
    </script>
</body>
</html>